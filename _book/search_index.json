[
["index.html", "Cyborg Math Final Project Chapter 1 Introduction", " Cyborg Math Final Project Nathaniel Starkman 2020-03-19 Chapter 1 Introduction This final project focuses on a rederivation of the analytic 0th and 1st order temperature and linear polarization results of Zaldarriaga and Harari (1995) in the Tight Coupling Approximation of the Cosmic Microwave Backgrounds. The Cosmic Microwave Background (CMB) can be described many ways but all essentially reduce to tracking the time evolution of small perturbations on a homogenous and isotropic background. Given the scale of the perturbations we can very well approximate the interactions using linear theory. This simplification only breaks down in the later universe when gravitationally bound systems start to form significant structure, such as clusters, galaxies, etc – all the way down to our very non-linear planet. There is a rich body of literature on the basic \\(\\Lambda\\)CDM model, knowledge of which will be assumed. For instance, it is assumed that fluctuations are adiabatic, not isothermal; the background is a Gaussian random field; that there are negligible intermediate velocity species which have a distinct equation of state from radiation or cold matter; that there are negligible thermal source terms such as decaying dark matter, etc. For the purposes of this project we track the temperature anisotropies of the CMB and observe how anisotropic Thompson scattering before and during the epoch of recombination induces polarization in the CMB on a wide range of angular scales. As a demonstration of Thompson-induced polarization, see the following graphic. Image Credit: Wayne Hu References "],
["imports-and-setup.html", "Chapter 2 Imports and Setup 2.1 Imports 2.2 Symbols and Sympy Functions 2.3 Relations 2.4 Passing Variables", " Chapter 2 Imports and Setup Each chapter includes the following code block, which is used to set the python environment. This should be changed to your python path to be run. library(reticulate) library(knitr) opts_chunk$set(engine.path=&#39;/Users/nathanielstarkman/miniconda3/bin/python3.7&#39;) The following imports and definitions may be found in the src folder of this project. They are included here for easy perusal, but are imported in each chapter with the following code block (hidden in chapters) from src import * 2.1 Imports These are the important imports from src import pickle import sympy as sp from sympy import pprint, Symbol, init_printing init_printing() from src.parameters import ( # Parameters # dummy&#39;s dummyL, dummyO, dummyMinus, dummyZero, dummyPlus, legendre_products_constants, # variables tau, tau0, mu, l, k, lge2, lge3, ) from .parameters import (LgP, DeltaT, DeltaP) # Functions to Make Parameters 2.2 Symbols and Sympy Functions There are many variables. Here is a table, in alphabetical order. Variable Symbol Explanation tau \\(\\tau\\) conformal time / distance tau0 \\(\\tau_0\\) current conformal time mu \\(\\mu\\) angle l \\(\\ell\\) Legendre \\(\\ell\\) k \\(k\\) vector dummyL \\(\\ell\\) dummy Legendre \\(\\ell\\) dummyO \\(\\mathcal{O}\\) dummy Taylor expansion order tauc \\(\\tau_C(\\tau)\\) inverse of Thompson scatter rate kappa \\(\\kappa(\\tau)\\) Thompson scattering dkappa \\(\\dot{\\kappa}(\\tau)\\) Thompson scattering rate a \\(a(\\tau)\\) scale factor R \\(R(\\tau)\\) \\(\\frac{3\\rho_b}{4\\rho_\\gamma}\\) Psi, Phi \\(\\Psi\\), \\(\\Phi\\) Bardeen potential DT \\(\\Delta_T\\) temperature fluctuation DP \\(\\Delta_P\\) Polarization fluctuation Sx \\(S_{TP}(\\tau)\\) \\(\\Delta_{T2} + \\Delta_{P2} - \\Delta_{P0}\\) 2.2.1 Variable Details Many of the variables have both order expansions in powers of tauc as well as multipole expansions in l. Additionally, many variables are implicitly functions of tau. In order to make reading these variables easier, they have been implemented using a custom Sympy function class that overloads the base LaTeX functionality. As example, a is \\(a(\\tau)\\), but will appear as \\(a\\) unless its argument is substituted to another variable (\\(a(x)\\) would appear as is). Similarly, DT is \\(\\Delta_{T,\\rm{multipole}}^{(\\rm{order})}(\\tau)\\) but shows as \\(\\Delta_T\\) unless the order, multipole or argument are changed. When the order or multipole do NOT appear, it means DT for ALL orders and/or multipoles. Besides overloading the LaTeX functionality, some functions, such as LgP and DP have custom .doit() methods and arguments to prevent their being expanded by their definitions (see next section). 2.2.2 Dummy Variables Dummy variables are used in function construction as a stand-in for unspecified values. This is done to protect variables from improper substitutions. Some of the dummy variables used in this paper are: Legendre degree \\(l\\): dummyL = Symbol(r&quot;\\mathcal{\\ell}&quot;) # Legendre l Taylor expansion order \\(\\mathcal{O}\\): dummyO = Symbol(r&quot;\\mathcal{O}&quot;) # order 2.3 Relations Sympy has powerful symbolic substutitution capabilities. We store relations and particular solutions in dictionaries for fast access and Sympy compatibilty. rels = { Sx : DT_a_2 + DP_a_2 - DP_a_0, tauc: 1/dkappa # R : } sols = {} # general solutions sols_0 = {} # 0th order solution sols_1 = {} # 1st order solution 2.4 Passing Variables Storing variables and relations for later chapters. vars = {} # save variables vars[&#39;rels&#39;] = rels vars[&#39;sols&#39;] = sols vars[&#39;sols_0&#39;] = sols_0 vars[&#39;sols_1&#39;] = sols_1 with open(&#39;src/pickled/01.pkl&#39;, &#39;wb&#39;) as file: pickle.dump(vars, file) with open(&#39;src/pickled/01.pkl&#39;, &#39;rb&#39;) as file: vars = pickle.load(file) rels = vars[&#39;rels&#39;] sols = vars[&#39;sols&#39;] sols_0 = vars[&#39;sols_0&#39;] sols_1 = vars[&#39;sols_1&#39;] "],
["definitions.html", "Chapter 3 Definitions 3.1 Fluctuation Multipole Expansion 3.2 Zaldarriaga and Harari (1995) (2.6) 3.3 All-order \\(\\Delta_T\\) relation 3.4 Passing Variables", " Chapter 3 Definitions 3.1 Fluctuation Multipole Expansion the multipole expansion of the temperature and polarization fluctuations in a given direction of observation \\(\\hat{n}\\) are written as DeltaTDef = sp.Eq(DT, DT.doit(i=l)) DeltaPDef = sp.Eq(DP, DP.doit(i=l)) \\[\\begin{eqnarray} \\Delta_{T} = \\sum_{\\ell=0}^{\\infty} \\left(2 \\ell + 1\\right) \\Delta_{T\\ell} \\rm{P}_{\\ell} \\\\ \\Delta_{P} = \\sum_{\\ell=0}^{\\infty} \\left(2 \\ell + 1\\right) \\Delta_{P\\ell} \\rm{P}_{\\ell} \\end{eqnarray}\\] where \\(P_\\ell\\) is the \\(\\ell\\)th Legendre polynomial. This is Zaldarriaga and Harari (1995) Equation 2.1 3.2 Zaldarriaga and Harari (1995) (2.6) The central equation to this project is Zaldarriaga and Harari (1995) (2.6), the Tight Coupling Approximation to the the evolution equations for the Fourier mode of wavevector \\(\\hat{k}\\) of the gauge-invariant temperature and polarization fluctuation as well as the equation of motion for the baryons. EqT = sp.Eq(DT - LgP(0) * DT_a_0 - LgP(1) * Vb - sp.Rational(1 / 2) * LgP(2) * Sx, -tauc * (dDT + sp.I * k * LgP(1) * (DT + Psi) + dPhi)).subs(Sx, rels[Sx]) EqP = sp.Eq(DP + sp.Rational(1 / 2) * (LgP(0) - LgP(2)) * Sx, -tauc * (dDP + sp.I * k * LgP(1) * DP)).subs(Sx, rels[Sx]) EqV = sp.Eq(3 * DT_a_1 - Vb, tauc * Rt * (sp.Derivative(a * Vb, tau) / a + sp.I * k * Psi)) \\[\\begin{align} - \\frac{\\left(- \\Delta_{P0} + \\Delta_{P2} + \\Delta_{T2}\\right) \\rm{P}_{2}}{2} - \\Delta_{T0} \\rm{P}_{0} + \\Delta_{T} - \\rm{P}_{1} \\rm{V}_{b} &amp;= - \\left(i k \\left(\\Delta_{T} + \\Psi\\right) \\rm{P}_{1} + \\frac{\\partial}{\\partial \\tau} \\Delta_{T} + \\frac{\\partial}{\\partial \\tau} \\Phi\\right) \\tau_C &amp; \\tag{3.1} \\\\ \\left(\\frac{\\rm{P}_{0}}{2} - \\frac{\\rm{P}_{2}}{2}\\right) \\left(- \\Delta_{P0} + \\Delta_{P2} + \\Delta_{T2}\\right) + \\Delta_{P} &amp;= - \\left(i k \\Delta_{P} \\rm{P}_{1} + \\frac{\\partial}{\\partial \\tau} \\Delta_{P}\\right) \\tau_C &amp; \\tag{3.2} \\\\ 3 \\Delta_{T1} - \\rm{V}_{b} &amp;= \\left(i k \\Psi + \\frac{\\frac{\\partial}{\\partial \\tau} \\rm{a} \\rm{V}_{b}}{\\rm{a}}\\right) \\rm{R} \\tau_C &amp; \\tag{3.3} \\end{align}\\] Where all terms have been defined in the previous section. We are considering a single Fourier mode in the z direction, and so expanding in \\(P_l(\\mu)\\). However, the relation between \\(Y_{l0}\\) and \\(P_l\\) is not the same as the relation between \\(._2Y_{l0}\\) and \\(P_l\\). In particular, while \\(Y_{l0}\\propto P_l\\), this is not the case for \\(._2Y_{l0}\\). For example \\(._2Y_{20}\\propto \\sin^2\\theta\\) and thus has both an expected \\(P_2\\) contribution and an unexpected \\(P_0\\) contribution. Thus \\(\\Delta_{P0}\\) is not automatically 0. Similarly \\(\\Delta_{P1}\\) is not automatically 0. 3.3 All-order \\(\\Delta_T\\) relation Look at \\(\\ell=0\\) piece of (3.1). The LHS is 0. The RHS is (dropping \\(\\tau_C\\)) \\[\\begin{equation} \\dot{\\Delta}_{T0}+\\dot{\\Phi} + ik\\Delta_{T1} \\end{equation}\\] Putting this together, aniT0to1 = sp.Eq( DT_a_0.diff(tau) + dPhi , -sp.I*k*DT_a_1 ) \\[\\begin{equation} \\frac{\\partial}{\\partial \\tau} \\Delta_{T0} + \\frac{\\partial}{\\partial \\tau} \\Phi = - i k \\Delta_{T1} \\tag{3.4} \\end{equation}\\] This is one of Z&amp;H95’s 1st order conclusions. (Middle equation of 2.8.) But actually this holds for \\(\\Delta_{T}\\) in general, and therefore order by order in \\(\\tau_C\\). 3.4 Passing Variables # save variables vars[&#39;DeltaTDef&#39;] = DeltaTDef vars[&#39;DeltaPDef&#39;] = DeltaPDef vars[&#39;tex_DeltaTDef&#39;] = tex_DeltaTDef vars[&#39;tex_DeltaPDef&#39;] = tex_DeltaPDef vars[&#39;EqT&#39;] = EqT vars[&#39;EqP&#39;] = EqP vars[&#39;EqV&#39;] = EqV vars[&#39;tex_EqT&#39;] = sp.latex(EqT) vars[&#39;tex_EqP&#39;] = sp.latex(EqP) vars[&#39;tex_EqV&#39;] = sp.latex(EqV) vars[&#39;aniT0to1&#39;] = aniT0to1 vars[&#39;tex_aniT0to1&#39;] = tex_aniT0to1 with open(&#39;src/pickled/02.pkl&#39;, &#39;wb&#39;) as file: pickle.dump(vars, file) References "],
["zeroth-order-solution.html", "Chapter 4 Zeroth-Order Solution", " Chapter 4 Zeroth-Order Solution (Zaldarriaga and Harari (1995) (2.7)) # loading with open(&#39;src/pickled/02.pkl&#39;, &#39;rb&#39;) as file: vars = pickle.load(file) DeltaTDef = vars[&#39;DeltaTDef&#39;] DeltaPDef = vars[&#39;DeltaPDef&#39;] EqT = vars[&#39;EqT&#39;] EqP = vars[&#39;EqP&#39;] EqV = vars[&#39;EqV&#39;] aniT0to1 = vars[&#39;aniT0to1&#39;] tex_aniT0to1 = vars[&#39;tex_aniT0to1&#39;] Solving Z&amp;H95 (2.6) at 0th order. The terms on the right go to 0. EqT_O0 = sp.Eq(EqT.lhs.subs(dummyO, 0), 0) EqP_O0 = sp.Eq(EqP.lhs.subs(dummyO, 0), 0) EqV_O0 = sp.Eq(EqV.lhs.subs(dummyO, 0), 0) \\[\\begin{align} - \\frac{\\left(- \\Delta_{P0}^{(0)} + \\Delta_{P2}^{(0)} + \\Delta_{T2}^{(0)}\\right) \\rm{P}_{2}}{2} - \\Delta_{T0}^{(0)} \\rm{P}_{0} + \\Delta_{T}^{(0)} - \\rm{P}_{1} \\rm{V}_{b}^{(0)} &amp;= 0 &amp; \\tag{4.1} \\\\ \\left(\\frac{\\rm{P}_{0}}{2} - \\frac{\\rm{P}_{2}}{2}\\right) \\left(- \\Delta_{P0}^{(0)} + \\Delta_{P2}^{(0)} + \\Delta_{T2}^{(0)}\\right) + \\Delta_{P}^{(0)} &amp;= 0 &amp; \\tag{4.2} \\\\ 3 \\Delta_{T1}^{(0)} - \\rm{V}_{b}^{(0)} &amp;= 0 &amp; \\tag{4.3} \\end{align}\\] We have already derived Z&amp;H95’s relation \\(\\frac{\\partial}{\\partial \\tau} \\Delta_{T0} + \\frac{\\partial}{\\partial \\tau} \\Phi = - i k \\Delta_{T1}\\) above – the middle equation of his (2.8) – in (3.4). Recall that this is true order-by-order, so the 0th order form is # temp = aniT0to1.subs(DT_a_0, DT_a_0.my_eval(l=0)) aniT0to1_O0 = aniT0to1.subs(dummyO, 0) \\[\\begin{equation} \\frac{d}{d \\tau} \\Delta_{T0}^{(0)} + \\frac{d}{d \\tau} \\Phi^{(0)} = - i k \\Delta_{T1}^{(0)}. \\tag{4.4} \\end{equation}\\] Rearranging (4.3), we find Z&amp;H95 (2.7a): ZH2p7a = sp.Eq(DT_0_1, sp.solve(EqV_O0, DT_0_1)[0]) \\[\\begin{equation} \\Delta_{T1}^{(0)} = \\frac{\\rm{V}_{b}^{(0)}}{3} \\tag{4.5} \\end{equation}\\] Now looking at (4.2), expanding order-by-order alltemp = sp.expand(EqP_O0.lhs) tempRHS = EqP_O0.rhs # l=0 temp = alltemp.subs(DP_0, DP_0.my_eval(l=0, fullsub=False)) temp = sp.collect(temp, LgP(0), evaluate=False)[LgP(0)] # collect powers of LgP(0) temp = temp.subs(LgP(0), 1) EqP_O0_l0 = sp.Eq(2 * tempRHS, 2 * temp) # l=1 temp = alltemp.subs(DP_0, DP_0.my_eval(l=1, fullsub=False)) temp = sp.collect(temp, LgP(1), evaluate=False)[LgP(1)] # collect powers of LgP(1) EqP_O0_l1 = sp.Eq(tempRHS / 3, temp / 3) # l=2 temp = alltemp.subs(DP_0, DP_0.my_eval(l=2, fullsub=False)) temp = sp.collect(temp, LgP(2), evaluate=False)[LgP(2)] # collect powers of LgP(2) EqP_O0_l2 = sp.Eq(2 * tempRHS, 2 * temp) # l&gt;=3 temp = alltemp.subs(DP_0, DP_0.my_eval(l=lge3, fullsub=False)).subs(l, lge3) temp_exp = sp.collect(temp, LgP(lge3), evaluate=False)[LgP(lge3)] # collect powers of LgP(&gt;=3) EqP_O0_lge3 = sp.Eq(tempRHS / (2*lge3 + 1), temp_exp / (2*lge3 + 1)) # just confirming if sp.collect(temp, LgP(4), evaluate=False).get(LgP(4), False) is not False: raise Exception() \\[\\begin{align} 0 &amp;= \\Delta_{P0}^{(0)} + \\Delta_{P2}^{(0)} + \\Delta_{T2}^{(0)} &amp; (\\ell=0) \\tag{4.6} \\\\ 0 &amp;= \\Delta_{P1}^{(0)} &amp; (\\ell=1) \\tag{4.7} \\\\ 0 &amp;= \\Delta_{P0}^{(0)} + 9 \\Delta_{P2}^{(0)} - \\Delta_{T2}^{(0)} &amp; (\\ell=2) \\tag{4.8} \\\\ 0 &amp;= \\Delta_{P\\mathcal{\\ell} \\geq 3}^{(0)} &amp; (\\ell \\geq 3) \\tag{4.9} \\end{align}\\] Substituting (4.6) into (4.8). temp = sp.Eq(EqP_O0_l0.lhs - EqP_O0_l2.lhs, EqP_O0_l0.rhs - EqP_O0_l2.rhs) # \\@ref(eq:O0Pl0)- \\@ref(eq:O0Pl2) O0PT2toP2 = sp.Eq(DP_0_2, sp.solve(temp, DP_0_2)[0]) \\[\\begin{equation} \\Delta_{P2}^{(0)} = \\frac{\\Delta_{T2}^{(0)}}{4} \\tag{4.10} \\end{equation}\\] Substitute (4.10) into (4.6). temp = EqP_O0_l0.subs(O0PT2toP2.lhs, O0PT2toP2.rhs) # sub O0PT2toP0 = sp.Eq(DP_0_0, sp.solve(temp, DP_0_0)[0]) # solve \\[\\begin{equation} \\Delta_{P0}^{(0)} = - \\frac{5 \\Delta_{T2}^{(0)}}{4} \\tag{4.11} \\end{equation}\\] These equations will prove inconsistent when analyzing the expansion of (4.1). Expanding (4.1) now, alltemp = sp.expand(EqT_O0.lhs) tempRHS = EqT_O0.rhs # l=0 temp = alltemp.subs(DT_0, DT_0.my_eval(l=0, fullsub=False)) temp = sp.collect(temp, LgP(0), evaluate=False).get(LgP(0), False) # collect powers of LgP(0) if temp is False: EqT_O0_l0 = sp.Eq(tempRHS, 0) else: raise Exception(str(temp)) # l=1 temp = alltemp.subs(DT_0, DT_0.my_eval(l=1, fullsub=False)) temp = sp.collect(temp, LgP(1), evaluate=False)[LgP(1)] # collect powers of LgP(1) EqT_O0_l1 = sp.Eq(tempRHS, temp) # l=2 temp = alltemp.subs(DT_0, DT_0.my_eval(l=2, fullsub=False)) temp = sp.collect(temp, LgP(2), evaluate=False)[LgP(2)] # collect powers of LgP(2) EqT_O0_l2 = sp.Eq(2 * tempRHS, 2 * temp) # l&gt;=3 temp = alltemp.subs(DT_0, DT_0.my_eval(l=lge3, fullsub=False)).subs(l, lge3) temp_exp = sp.collect(temp, LgP(lge3), evaluate=False)[LgP(lge3)] # collect powers of LgP(l&gt;=3) EqT_O0_lge3 = sp.Eq(tempRHS / (2*lge3 + 1), temp_exp / (2*lge3 + 1)) # just confirming if sp.collect(temp, LgP(4), evaluate=False).get(LgP(4), False) is not False: raise Exception() \\[\\begin{align} &amp;\\text{True} \\quad \\text{$\\Delta^{(0)}_{T0}$ is a free parameter.} &amp; (\\ell = 0) \\tag{4.12} \\\\ 0 &amp;= 3 \\Delta_{T1}^{(0)} - \\rm{V}_{b}^{(0)} &amp; \\text{see (4.4)} \\quad (\\ell=1) \\\\ 0 &amp;= \\Delta_{P0}^{(0)} - \\Delta_{P2}^{(0)} + 9 \\Delta_{T2}^{(0)} &amp; (\\ell=2) \\tag{4.13} \\\\ 0 &amp;= \\Delta_{T\\mathcal{\\ell} \\geq 3}^{(0)} &amp; (\\ell \\geq 3) \\tag{4.14} \\end{align}\\] Combining (4.13) with (4.8). temp = sp.Eq(EqT_O0_l2.lhs - EqP_O0_l2.lhs, EqT_O0_l2.rhs - EqP_O0_l2.rhs) O0T2P2 = sp.Eq(DP_0_2, sp.solve(temp, DP_0_2)[0]) \\[\\begin{equation} \\Delta_{P2}^{(0)} = \\Delta_{T2}^{(0)} \\tag{4.15} \\end{equation}\\] Comparing this with (4.10) we see the incompatibility of the two equations. Therefore, tempLHS = O0T2P2.lhs - O0PT2toP2.lhs tempRHS = O0T2P2.rhs - O0PT2toP2.rhs O0T2sol = sp.Eq(sp.Rational(4,3)*tempRHS, sp.Rational(4,3)*tempLHS) # and subbing into P equation O0P2sol = O0T2P2.subs(sp.solve(O0T2sol, DT_0_2, dict=True)[0]) \\[\\begin{align} \\Delta_{T2}^{(0)} &amp;= 0 &amp; \\tag{4.16} \\\\ \\Delta_{P2}^{(0)} &amp;= 0 &amp; \\tag{4.17} \\end{align}\\] Substituting this into (4.11) we again see the incompatibility of the two equations. Therefore, O0P0sol = O0PT2toP0.subs(sp.solve(O0T2sol, DT_0_2, dict=True)[0]) \\[\\begin{equation} \\Delta_{P0}^{(0)} = 0 \\end{equation}\\] Putting all these relations together we get Z&amp;H95 (2.7), # ZH2p7a already done if ( (sp.solve(O0P0sol, DP_0_0)[0] == 0) &amp; (sp.solve(EqP_O0_l1, DP_0_1)[0] == 0) &amp; (sp.solve(O0P2sol, DP_0_2)[0] == 0) &amp; (sp.solve(EqP_O0_lge3, DP_0_ge3)[0] == 0) ): O0Psol = sp.Eq(DP_0, 0) if ( (sp.solve(O0T2sol, DT_0_2)[0] == 0) &amp; (sp.solve(EqT_O0_lge3, DT_0_ge3)[0] == 0) ): O0Tsol = sp.Eq(DT_0.subs(dummyL, lge2), 0) \\[\\begin{align} \\Delta_{T1}^{(0)} = \\frac{\\rm{V}_{b}^{(0)}}{3} \\quad , \\quad \\Delta_{P}^{(0)} = 0 \\quad , \\quad \\Delta_{T\\mathcal{\\ell} \\geq 2}^{(0)} = 0 \\end{align}\\] vars[&#39;aniT0to1_O0&#39;] = aniT0to1_O0 vars[&#39;tex_aniT0to1_O0&#39;] = tex_aniT0to1_O0 vars[&#39;O0Tsol&#39;] = {DT_0: DT_0.doit(i=l).subs(sp.oo, 1).doit()} with open(&#39;src/pickled/03.pkl&#39;, &#39;wb&#39;) as file: pickle.dump(vars, file) References "],
["first-order-solution.html", "Chapter 5 First Order Solution", " Chapter 5 First Order Solution (Zaldarriaga and Harari (1995) (2.8)) # load with open(&#39;src/pickled/03.pkl&#39;, &#39;rb&#39;) as file: vars = pickle.load(file) DeltaTDef = vars[&#39;DeltaTDef&#39;] DeltaPDef = vars[&#39;DeltaPDef&#39;] EqT = vars[&#39;EqT&#39;] EqP = vars[&#39;EqP&#39;] EqV = vars[&#39;EqV&#39;] aniT0to1 = vars[&#39;aniT0to1&#39;] tex_aniT0to1 = vars[&#39;tex_aniT0to1&#39;] aniT0to1_O0 = vars[&#39;aniT0to1_O0&#39;] tex_aniT0to1_O0 = vars[&#39;tex_aniT0to1_O0&#39;] O0Tsol = vars[&#39;O0Tsol&#39;] The first order expansions of (3.1)-(3.3) are given by EqT_O1 = sp.Eq(EqT.lhs.subs(dummyO, 1), EqT.rhs.subs(dummyO, 0)) EqP_O1 = sp.Eq(EqP.lhs.subs(dummyO, 1), EqP.rhs.subs(dummyO, 0)) EqV_O1 = sp.Eq(EqV.lhs.subs(dummyO, 1), EqV.rhs.subs(dummyO, 0)) \\[\\begin{align} - \\frac{\\left(- \\Delta_{P0}^{(1)} + \\Delta_{P2}^{(1)} + \\Delta_{T2}^{(1)}\\right) \\rm{P}_{2}}{2} - \\Delta_{T0}^{(1)} \\rm{P}_{0} + \\Delta_{T}^{(1)} - \\rm{P}_{1} \\rm{V}_{b}^{(1)} &amp;= - \\left(i k \\left(\\Delta_{T}^{(0)} + \\Psi^{(0)}\\right) \\rm{P}_{1} + \\frac{\\partial}{\\partial \\tau} \\Delta_{T}^{(0)} + \\frac{d}{d \\tau} \\Phi^{(0)}\\right) \\tau_C &amp; \\tag{5.1} \\\\ \\left(\\frac{\\rm{P}_{0}}{2} - \\frac{\\rm{P}_{2}}{2}\\right) \\left(- \\Delta_{P0}^{(1)} + \\Delta_{P2}^{(1)} + \\Delta_{T2}^{(1)}\\right) + \\Delta_{P}^{(1)} &amp;= - \\left(i k \\Delta_{P}^{(0)} \\rm{P}_{1} + \\frac{\\partial}{\\partial \\tau} \\Delta_{P}^{(0)}\\right) \\tau_C &amp; \\tag{5.2} \\\\ 3 \\Delta_{T1}^{(1)} - \\rm{V}_{b}^{(1)} &amp;= \\left(i k \\Psi^{(0)} + \\frac{\\frac{d}{d \\tau} \\rm{a} \\rm{V}_{b}^{(0)}}{\\rm{a}}\\right) \\rm{R} \\tau_C &amp; \\tag{5.3} \\end{align}\\] We have already derived Z&amp;H95’s relation \\(\\frac{\\partial}{\\partial \\tau} \\Delta_{T0} + \\frac{\\partial}{\\partial \\tau} \\Phi = - i k \\Delta_{T1}\\) above – the middle equation of his (2.8) – in (3.4). Recall that this is true order-by-order, so the first order form is aniT0to1_O1 = aniT0to1.subs(dummyO, 1) \\[\\begin{equation} \\frac{d}{d \\tau} \\Delta_{T0}^{(1)} + \\frac{d}{d \\tau} \\Phi^{(1)} = - i k \\Delta_{T1}^{(1)}. \\tag{5.4} \\end{equation}\\] In the following derivation we do not need to use (5.3), however note that the RHS of @ref(eq:O1_Vb)\\(= \\tau_C\\left[3R\\dot{\\Delta}_{T1}^{(0)} + 3\\dot{R}\\Delta_{T1}^{(0)} + ikR\\Psi^{(0)} \\right]\\), which could be a more convenient form. Consider (5.2). Since Z&amp;H95 find \\(\\Delta_{P} = 0\\), The RHS of (5.2)\\(=0\\). Therefore @ref(eq:O1_P) may be written as EqP_O1_simp = EqP_O1.subs(DP_0, 0).doit() EqP_O1_simp = sp.Eq(EqP_O1_simp.rhs, EqP_O1_simp.lhs) \\[\\begin{align} 0 &amp;= \\left(\\frac{\\rm{P}_{0}}{2} - \\frac{\\rm{P}_{2}}{2}\\right) \\left(- \\Delta_{P0}^{(1)} + \\Delta_{P2}^{(1)} + \\Delta_{T2}^{(1)}\\right) + \\Delta_{P}^{(1)} \\tag{5.5} \\end{align}\\] Looking at the \\(\\ell\\) components of (5.5) if EqP_O1_simp.lhs != 0: # ensuring EqP_O1_simp.lhs == 0 for simplification raise Exception() alltemp = sp.expand(EqP_O1_simp.rhs) tempLHS = EqP_O1_simp.lhs # l=0 temp = alltemp.subs(DP_1, DP_1.my_eval(l=0, fullsub=False)) # evaluate DP_1 temp = sp.collect(temp, LgP(0), evaluate=False)[LgP(0)] # collect powers of LgP(0) EqP_O1_l0 = sp.Eq(2*tempLHS, 2*temp) # l=1 temp = alltemp.subs(DP_1, DP_1.my_eval(l=1, fullsub=False)) # evaluate DP_1 temp = sp.collect(temp, LgP(1), evaluate=False)[LgP(1)] # collect powers of LgP(1) EqP_O1_l1 = sp.Eq(tempLHS/3, temp/3) # l=2 temp = alltemp.subs(DP_1, DP_1.my_eval(l=2, fullsub=False)) # evaluate DP_1 temp = sp.collect(temp, LgP(2), evaluate=False)[LgP(2)] # collect powers of LgP(2) EqP_O1_l2 = sp.Eq(2*tempLHS, 2*temp) # l=3 temp = alltemp.subs(DP_1, DP_1.my_eval(l=3, fullsub=False)) # evaluate DP_1 temp = sp.collect(temp, LgP(3), evaluate=False)[LgP(3)] # collect powers of LgP(3) EqP_O1_lge3 = sp.Eq(tempLHS/7, temp/7) \\[\\begin{align} 0 &amp;= \\Delta_{P0}^{(1)} + \\Delta_{P2}^{(1)} + \\Delta_{T2}^{(1)} &amp; \\text{($\\ell=0$)} \\tag{5.6} \\\\ 0 &amp;= \\Delta_{P1}^{(1)} &amp; \\text{Z&amp;H96 (2.8c) #2, ($\\ell=1$)} \\tag{5.7}\\\\ 0 &amp;= \\Delta_{P0}^{(1)} + 9 \\Delta_{P2}^{(1)} - \\Delta_{T2}^{(1)} &amp; \\text{($\\ell=2$)} \\tag{5.8}\\\\ 0 &amp;= \\Delta_{P3}^{(1)} &amp; \\text{Z&amp;H95 (2.8c) #1b ($\\ell \\geq 3$)} \\tag{5.9} \\end{align}\\] Adding the \\(\\ell=0\\) and \\(\\ell=2\\) relations, temp = sp.Eq(EqP_O1_l0.lhs + EqP_O1_l2.lhs, EqP_O1_l0.rhs + EqP_O1_l2.rhs) ZH2p8a1 = sp.Eq(DP_1_2, sp.solve(temp, DP_1_2)[0]) \\[\\begin{equation} \\Delta_{P2}^{(1)} = - \\frac{\\Delta_{P0}^{(1)}}{5}, \\tag{5.10} \\end{equation}\\] which is one of the relationships of Z&amp;H95 (2.8a). Substitute (5.10) into (5.6), and solve to find temp = sp.solve(ZH2p8a1, DP_1_2, dict=True)[0] # solve for substitution temp = EqP_O1_l0.subs(temp) # substitute into EqP_O1_l0 ZH2p8a2 = sp.Eq(DT_1_2, sp.solve(temp, DT_1_2)[0]) \\[\\begin{equation} \\Delta_{T2}^{(1)} = - \\frac{4 \\Delta_{P0}^{(1)}}{5}, \\tag{5.11} \\end{equation}\\] which is one another relationship in Z&amp;H95 (2.8a). Now consider (5.1). The RHS of (5.1) may be rewritten as EqT_O1_RHS = EqT_O1.rhs # because $\\dot{\\Delta}_{T}^{(0)} + \\dot{\\Phi}^{(0)} = -ik\\Delta_{T1}^{(0)}$, where $\\Delta_{T\\ell}^{(0)} = 0 tempeq = EqT_O1_RHS.subs(O0Tsol) tempeq = sp.simplify(tempeq.subs(sp.solve(aniT0to1_O0, dPhi_0, dict=True)[0])) # need to cancel terms, so expand and substitute tempeq = sp.expand(tempeq) tempeq = tempeq.subs(LgP(0)*LgP(1), LgP(1)).subs(LgP(1)*LgP(1), 2*LgP(2)/3 + LgP(0)/3) # from appendix tempeq = tempeq.subs(LgP(0), 1) # for cancelling EqT_O1_RHS_exp = sp.simplify(tempeq) \\[\\begin{align} \\rm{RHS} &amp;=- \\left(i k \\left(\\Delta_{T}^{(0)} + \\Psi^{(0)}\\right) \\rm{P}_{1} + \\frac{\\partial}{\\partial \\tau} \\Delta_{T}^{(0)} + \\frac{d}{d \\tau} \\Phi^{(0)}\\right) \\tau_C &amp; \\\\ &amp;= - \\left(i k \\Delta_{T0}^{(0)} \\rm{P}_{1} + 2 i k \\Delta_{T1}^{(0)} \\rm{P}_{2} + i k \\rm{P}_{1} \\Psi^{(0)} + 3 \\rm{P}_{1} \\frac{d}{d \\tau} \\Delta_{T1}^{(0)}\\right) \\tau_C &amp; \\tag{5.12} \\end{align}\\] The LHS of (5.1) requires a similar treatment. Start by expanding \\(\\Delta_{T}\\) to first order, # define general order expansion DT_Oexp = sp.Eq(DT, sp.summation(DT.subs(dummyO, i) * tauc**i, (i, 0, sp.oo))) # take up to O=1 DT_O1exp = DT_Oexp.subs(sp.oo, 1).doit() DT_O1expfull = sp.Eq(DT_O1exp.lhs, DT_O1exp.rhs.doit(i=l)) # sub l expansion \\[\\begin{equation} \\Delta_{T} = \\Delta_{T}^{(0)} + \\Delta_{T}^{(1)} \\tau_C \\rightarrow \\Delta_{T} = \\tau_C \\sum_{\\ell=0}^{\\infty} \\left(2 \\ell + 1\\right) \\Delta_{T\\ell}^{(1)} \\rm{P}_{\\ell} + \\sum_{\\ell=0}^{\\infty} \\left(2 \\ell + 1\\right) \\Delta_{T\\ell}^{(0)} \\rm{P}_{\\ell} \\tag{5.13} \\end{equation}\\] Substituting this into the LHS of (5.1), where we drop the 0th order term since we are in the 1st order expansion. temp = sp.Eq( # 1st order DT_O1expfull.lhs.subs(DT, DT_1), # go to 1st order sp.collect(DT_O1expfull.rhs, tauc, evaluate=False)[tauc] # go to 1st order ) temp_tosub = sp.solve(temp, DT_1, dict=True)[0] # solve for DT_1, which want to sub in # however, this will not cancel some terms, so need to rewrite temp = temp_tosub[DT_1].args[0] # summand temp_ind, temp_from, temp_to = temp_tosub[DT_1].args[1] # summation index set temp_tosub[DT_1] = ( temp.subs(l, temp_from) + temp.subs(l, temp_from + 1) + temp.subs(l, temp_from + 2) + sp.Sum(temp, (temp_ind, temp_from+3, temp_to)) ) # re-sum, breaking out 1st 2 summands EqT_O1_LHS = sp.simplify(EqT_O1.lhs.subs(temp_tosub)) \\[\\begin{align} \\rm{LHS} &amp;= - \\frac{\\left(- \\Delta_{P0}^{(1)} + \\Delta_{P2}^{(1)} + \\Delta_{T2}^{(1)}\\right) \\rm{P}_{2}}{2} - \\Delta_{T0}^{(1)} \\rm{P}_{0} + \\Delta_{T}^{(1)} - \\rm{P}_{1} \\rm{V}_{b}^{(1)} \\\\ &amp;= \\frac{\\Delta_{P0}^{(1)} \\rm{P}_{2}}{2} - \\frac{\\Delta_{P2}^{(1)} \\rm{P}_{2}}{2} + 3 \\Delta_{T1}^{(1)} \\rm{P}_{1} + \\frac{9 \\Delta_{T2}^{(1)} \\rm{P}_{2}}{2} - \\rm{P}_{1} \\rm{V}_{b}^{(1)} + \\sum_{\\ell=3}^{\\infty} \\left(2 \\ell + 1\\right) \\Delta_{T\\ell}^{(1)} \\rm{P}_{\\ell} &amp; \\tag{5.13} \\end{align}\\] Putting the LHS and RHS together and looking at the \\(\\ell\\) components of (5.1) individually. tempLHS = sp.expand(EqT_O1_LHS) tempRHS = sp.expand(EqT_O1_RHS_exp) # l=0 O1_T_l0_LHS = sp.collect(tempLHS, LgP(0), evaluate=False).get(LgP(0), 0) O1_T_l0_RHS = sp.collect(tempRHS, LgP(0), evaluate=False).get(LgP(0), 0) # l=1 O1_T_l1_LHS = sp.collect(tempLHS, LgP(1), evaluate=False).get(LgP(1), 0) temp = tempRHS.subs(DT_0, DT_0.my_eval(l=1)) O1_T_l1_RHS = sp.simplify(sp.collect(temp, LgP(1), evaluate=False).get(LgP(1), 0)) # l=2 O1_T_l2_LHS = sp.collect(tempLHS, LgP(2), evaluate=False).get(LgP(2), 0) O1_T_l2_RHS = sp.simplify(sp.collect(tempRHS, LgP(2), evaluate=False).get(LgP(2), 0)) O1_T_l2 = sp.Eq(O1_T_l2_LHS, O1_T_l2_RHS) # l&gt;=3 temp = sp.simplify(tempLHS - (O1_T_l0_LHS * LgP(0) + O1_T_l1_LHS * LgP(1) + O1_T_l2_LHS * LgP(2))) O1_T_lge3_LHS = temp.args[0].subs(l, lge3) # break apart summation b/c term by term O1_T_lge3_RHS = sp.simplify(sp.collect(temp, LgP(3), evaluate=False).get(LgP(3), 0)) if O1_T_lge3_RHS == 0: O1_T_lge3_LHS = O1_T_lge3_LHS / (2*lge3 + 1) / LgP(lge3) # just simplifying out constants O1_T_lge3 = sp.Eq(O1_T_lge3_LHS, O1_T_lge3_RHS) \\[\\begin{align} 0 &amp;= 0 &amp; ($\\ell=0$) \\tag{5.14} \\\\ 3 \\Delta_{T1}^{(1)} - \\rm{V}_{b}^{(1)} &amp;= - \\left(i k \\Delta_{T0}^{(0)} + i k \\Psi^{(0)} + 3 \\frac{d}{d \\tau} \\Delta_{T1}^{(0)}\\right) \\tau_C &amp; ($\\ell=1$) \\tag{5.15} \\\\ \\frac{\\Delta_{P0}^{(1)}}{2} - \\frac{\\Delta_{P2}^{(1)}}{2} + \\frac{9 \\Delta_{T2}^{(1)}}{2} &amp;= - 2 i k \\Delta_{T1}^{(0)} \\tau_C &amp; ($\\ell=2$) \\tag{5.16} \\\\ \\Delta_{T\\mathcal{\\ell} \\geq 3}^{(1)} &amp;= 0 &amp;\\text{Z&amp;H95 (2.8c) #1a} ($\\ell \\geq 3$) \\tag{5.17} \\\\ \\end{align}\\] Now substitute (5.10) and (5.11) into (5.16) O1_T_l2 = O1_T_l2.subs(sp.solve(ZH2p8a1, DP_1_2, dict=True)[0]) O1_T_l2 = O1_T_l2.subs(sp.solve(ZH2p8a2, DP_1_0, dict=True)[0]) O1_T_l2 = sp.Eq(DT_1_2, sp.simplify(sp.solve(O1_T_l2, DT_1_2)[0])) \\[\\begin{equation} \\Delta_{T2}^{(1)} = - \\frac{8 i k \\Delta_{T1}^{(0)} \\tau_C}{15} \\tag{5.18} \\end{equation}\\] Putting all the derived equations together. \\[\\begin{align} &amp;\\Delta_{P2}^{(1)} = - \\frac{\\Delta_{P0}^{(1)}}{5}, \\quad \\Delta_{T2}^{(1)} = - \\frac{4 \\Delta_{P0}^{(1)}}{5} \\quad;\\quad \\Delta_{T2}^{(1)} = - \\frac{8 i k \\Delta_{T1}^{(0)} \\tau_C}{15} \\\\ &amp;\\frac{d}{d \\tau} \\Delta_{T0}^{(1)} + \\frac{d}{d \\tau} \\Phi^{(1)} = - i k \\Delta_{T1}^{(1)} \\\\ &amp;\\Delta_{T\\mathcal{\\ell} \\geq 3}^{(1)} = 0, \\quad 0 = \\Delta_{P3}^{(1)} \\ \\forall \\ell \\geq 3 \\quad;\\quad 0 = \\Delta_{P1}^{(1)} \\end{align}\\] References "],
["appendix.html", "Chapter 6 Appendix 6.1 Legendre Products 6.2 Approximations", " Chapter 6 Appendix 6.1 Legendre Products It’s useful to note that the product \\(\\rm{P}_{2} \\rm{P}_{\\ell}\\), can easily be expressed as a linear combination of \\(\\rm{P}_{\\ell+2}\\), \\(\\rm{P}_{\\ell}\\), and \\(\\rm{P}_{\\ell-2}\\). We derive the coefficients: \\[\\begin{equation} \\mu \\rm{P}_{\\ell} = \\frac{l+1}{2l+1} \\rm{P}_{\\ell+1} + \\frac{l}{2l+1}\\rm{P}_{\\ell-1} \\end{equation}\\] Applying this again, \\[\\begin{eqnarray} \\mu^2 \\rm{P}_{\\ell} &amp;=&amp; \\frac{l+1}{2l+1} \\left( \\frac{l+2}{2l+3} \\rm{P}_{\\ell+2} + \\frac{l+1}{2l+3}\\rm{P}_{\\ell} \\right) \\\\ &amp;&amp;\\,+ \\frac{l}{2l+1}\\left( \\frac{l}{2l-1} \\rm{P}_{\\ell} + \\frac{l-1}{2l-1}\\rm{P}_{\\ell-2} \\right) \\nonumber \\\\ &amp;=&amp; \\frac{(l+2)(l+1)}{(2l+3)(2l+1)}\\rm{P}_{\\ell+2} + \\frac{1}{2l+1}\\left(\\frac{(l+1)^2}{2l+3} + \\frac{l^2}{2l-1}\\right) \\rm{P}_{\\ell} \\nonumber\\\\ &amp;&amp;\\,+ \\frac{l(l-1)}{(2l+1)(2l-1)}\\rm{P}_{\\ell-2}\\nonumber\\\\ &amp;=&amp; \\frac{(l+2)(\\ell+1)}{(2\\ell+3)(2\\ell+1)}\\rm{P}_{\\ell+2} + \\frac{2\\ell^2 + 2\\ell - 1}{(2\\ell+3)(2\\ell-1)}\\rm{P}_{\\ell} \\nonumber\\\\ &amp;&amp;\\,+ \\frac{\\ell(\\ell-1)}{(2\\ell+1)(2\\ell-1)}\\rm{P}_{\\ell-2}\\nonumber \\end{eqnarray}\\] use \\[\\begin{eqnarray} \\rm{P}_{2}\\rm{P}_{\\ell} &amp;=&amp; \\frac{1}{2}(3\\mu^2-1)\\rm{P}_{\\ell}\\\\ &amp;=&amp; a_\\ell^+\\rm{P}_{\\ell+2} + a_\\ell^0\\rm{P}_{\\ell} + a_\\ell^-\\rm{P}_{\\ell-2} \\nonumber \\end{eqnarray}\\] Therefore \\[\\begin{eqnarray} a_\\ell^+ &amp;=&amp; \\frac{3}{2}\\frac{(\\ell+2)(\\ell+1)}{(2\\ell+3)(2\\ell+1)} \\\\ a_\\ell^0 &amp;=&amp; \\frac{\\ell(\\ell+1)}{(2\\ell+3)(2\\ell-1)} \\\\ a_\\ell^- &amp;=&amp; \\frac{3}{2}\\frac{\\ell(\\ell-1)}{(2\\ell+1)(2\\ell-1)} \\end{eqnarray}\\] Similarly for the \\(b&#39;s\\) \\[\\begin{eqnarray} (1 - \\rm{P}_{2})\\rm{P}_{\\ell} &amp;=&amp; \\frac{3}{2}(1-\\mu^2)\\rm{P}_{\\ell} \\\\ &amp;=&amp; b_\\ell^+\\rm{P}_{\\ell+2} + b_\\ell^0\\rm{P}_{\\ell} + b_\\ell^-\\rm{P}_{\\ell-2} \\end{eqnarray}\\] so \\[\\begin{eqnarray} b_\\ell^+ &amp;=&amp; -a_\\ell^+ \\\\ b_\\ell^0 &amp;=&amp; -3 \\frac{\\ell^2 + \\ell - 1}{(2\\ell+3)(2\\ell-1)} \\\\ b_\\ell^- &amp;=&amp; -b_\\ell^- \\end{eqnarray}\\] 6.2 Approximations 6.2.1 R and a Zaldarriaga defines \\(R \\equiv \\frac{3\\rho_b}{4\\rho_\\gamma}\\) This means \\(\\frac{\\dot{R}}{R} \\approxeq \\frac{\\dot{a}}{a}\\), where corrections are of order the momentum of the baryons and potentially also the correct consideration of the neutrinos. Zaldarriaga, Matı́as, and Diego D Harari. 1995. “Analytic approach to the polarization of the cosmic microwave background in flat and open universes.” Physical Review D. "]
]
